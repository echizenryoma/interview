## 搜索树

### 二叉查找树

二叉查找树的发现完全是因为静态查找结构在动态插入，删除结点所表现出来的无能为力（需要付出极大的代价）。

**复杂度**

* 查找：任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。
   - 当树中每个结点左右子树高度大致相同时，树高为$$O(\log_2{N})$$，则平均查找长度与$$O(\log_2{N})$$成正比，查找的平均时间复杂度为$$O(\log_2{N})$$。

   - 当先后插入的关键字有序时，二叉查找树退化成单支树结构。此时树高$$n$$。平均查找长度为$$\frac{n+1}{2}$$，查找的平均时间复杂度为$$O(N)$$

* 插入：新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。

* 删除：当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为$$O(1)$$。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的...的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度为$$O(\log_2{N})$$。
   

**总结**

* 查找最好时间复杂度$$O(\log_2{N})$$，最坏时间复杂度$$O(N)$$。
* 插入删除操作算法简单，时间复杂度与查找差不多


### 平衡二叉查找树

**复杂度**

* 查找：平衡二叉查找树是严格平衡的二叉查找树。那么查找过程与二叉查找树一样，只是AVL不会出现最差情况的单支树。因此查找效率最好，最坏情况都$$O(\log_2{N})$$
* 插入代价： 平衡二叉查找树为了保证严格平衡，那么每一次插入数据使得平衡二叉查找树中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次（单旋转或双旋转）。因此，总体上插入操作的时间复杂度仍然在$$O(\log_2{N})$$（插入结点需要首先查找插入的位置）
* 删除代价：平衡二叉查找树删除结点的算法可以参见二叉查找树的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要$$O(\log_2{N})$$次旋转。因此，删除操作的时间复杂度为$$O(2\log_2{N})$$

### 红黑树

红黑树即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率。

**复杂度**

* 查找：由于红黑树的性质（最长路径长度不超过最短路径长度的2倍），可以说明红黑树虽然不像平衡二叉查找树一样是严格平衡的，但平衡性能还是要比二叉查找树要好。其查找代价基本维持在O(logN)左右，但在最差情况下（最长路径是最短路径的2倍少1），比平衡二叉查找树要略逊色一点。
* 插入：红黑树插入结点时，需要旋转操作和变色操作。但由于只需要保证红黑树基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和平衡二叉查找树的插入操作一样。虽然变色操作需要$$O(\log_2{N})$$，但是变色操作十分简单，代价很小。
* 删除：红黑树的删除操作代价要比平衡二叉查找树要好的多，删除一个结点最多只需要3次旋转操作。

### B树

**复杂度**

* 查找：B树作为一个平衡多路查找树。B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址（查找地址），查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找（可以用折半），相比查找代价极低。而B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。
* 插入： B树的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为$$h（读取搜索路径上的节点）＋2s（回写两个分裂出的新节点）＋1（回写新的根节点或插入后没有导致分裂的节点）$$。因此，所需要的磁盘访问次数是$$h+2s+1$$，最多可达到$$3h+1$$。因此插入的代价是很大的。
* 删除代价：B树的删除会发生结点合并操作。最坏情况下磁盘访问次数是$$3h=（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）$$
