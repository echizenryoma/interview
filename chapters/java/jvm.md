## Java虚拟机（JVM）

### 体系结构

![](/assets/jvm-architecture.svg)

每个Java虚拟机都有一个类装载器子系统，他根据给定的全限定名来装在类型。同样，每个Java虚拟机都有一个执行引擎，它负责执行那些包含在被装载类的方法中的指令。

**每个Java虚拟机实例都有一个方法区以及一个堆，**他们是由**该虚拟机实例中所有线程共享的。** 当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息。**然后把这些类型信息放到方法区中。** 当程序运行的时候，**虚拟机会把所有该程序在运行时创建的对象都放到堆中。**

**每个新线程都会得到它自己的PC寄存器(程序计数器)以及一个Java栈。**

**Java栈是由很多的栈帧（stack frame）或者说帧（frame）组成的，一个栈帧包含一个Java方法调用状态。**当现场调用一个Java方法的时候，虚拟机压入一个新的栈帧到该线程的Java栈中：当该方法返回时，这个栈帧被从Java栈中弹出并抛弃。

Java虚拟机没有指令寄存器，其指令集使用Java栈来存储中间数据。这样设计的原因是为了保持Java虚拟机的指令集尽量紧凑、同时也便于Java虚拟机在那些只有很少通用寄存器的平台上实现。另外，Java虚拟机这种基于栈的体系结构，也有助于运行时某些虚拟机实现的动态编译器和即时编译器的代码优化。

### 类装载器

#### 分类

![](/assets/java-class-loader.svg)

* `启动类加载器（Bootstrap ClassLoader）`负责加载存放在`$JAVA_HOME\jre\lib`下，或被`-Xbootclasspath`参数指定的路径中的，并且能被虚拟机识别的类库
* `扩展类加载器（Extension ClassLoader）`该加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载`$JAVA_HOME\jre\lib\ext`目录中，或者由`java.ext.dirs`系统变量指定的路径中的所有类库（如`javax.*`开头的类），开发者可以直接使用扩展类加载器。
* `应用程序类加载器（Application ClassLoader）`该类加载器由`sun.misc.Launcher$AppClassLoader`来实现，它负责加载用户类路径（`ClassPath`）所指定的类，开发者可以直接使用该类加载器

#### 装载步骤

类装载器子系统除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为变量分配初始化内存，以及帮助解析符号引用。这些动作必须严格按一下顺序完成：

  1. 装载：查找并装载类型的二进制数据。
  2. 链接：执行验证、准备以及解析(可选)
    - 验证：确保被导入类型的正确性
    - 准备：为类变量分配内存，并将其初始化为默认值。
    - 解析：把类型中的符号引用转换为直接引用。
  3. 初始化：把类变量初始化为正确的初始值。
  
### 内存模型

![](/assets/java-memory-model.svg)

#### 控制参数

* `-Xms`设置堆的最小空间大小
* `-Xmx`设置堆的最大空间大小
* `-XX:NewSize`设置新生代最小空间大小
* `-XX:MaxNewSize`设置新生代最大空间大小
* `-XX:PermSize`设置永久代最小空间大小（JDK 1.7及以前）
* `-XX:MaxPermSize`设置永久代最大空间大小（JDK 1.7及以前）
* `-XX:MetaspaceSize`设置元空间最小空间大小（JDK 1.8及以后）
* `-XX:MaxMetaspaceSize`设置元空间最大空间大小（JDK 1.8及以后）
* `-Xss`设置每个线程的堆栈大小

##### 注意

1. 没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。`老年代空间大小=堆空间大小-年轻代大空间大小`
2. 方法区和堆是所有线程共享的内存区域；而Java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。
