## MySQL

### 范式

#### 第一范式

符合第一范式的关系中的每个属性都不可再分。

不符合第一范式的实例：

![](/assets/database-1nf.jpg)

#### 第二范式

消除了非主属性对于码的部分函数依赖

码：设K为某表中的一个属性或属性组，若除K之外的所有属性都完全函数依赖于K，那么称K为候选码，简称为码。在实际中我们通常可以理解为：假如当K确定的情况下，该表除K之外的所有属性的值也就随之确定，那么K就是码。

### 引擎对比

1. 存储结构

MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD \(MYData\)。索引文件的扩展名是.MYI \(MYIndex\)。

InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小。

2. 存储空间

MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表、动态表、压缩表。

InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

3. 事务支持

MyISAM：强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。

InnoDB：提供事务支持事务，外部键等高级数据库功能。具有事务\(commit\)、回滚\(rollback\)和崩溃修复能力\(crash recovery capabilities\)的事务安全\(transaction-safe \(ACID compliant\)\)型表。

4. AUTO\_INCREMENT

MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。

InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。

5. 表锁差异

MyISAM：只支持表级锁，用户在操作MyISAM表时，SELECT、UPDATE、DELTE、INSERT语句都会给表自动加锁，如果加锁以后的表满足INSERT并发的情况下，可以在表的尾部插入新的数据。

InnoDB：支持事务和行级锁，是InnoDB的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。

6. 全文索引

MyISAM：支持FULLTEXT类型的全文索引

InnoDB：5.6及之前版本不支持FULLTEXT类型的全文索引

7. 表主键

MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。

InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键\(用户不可见\)，数据是主索引的一部分，附加索引保存的是主索引的值。

8. 表的总行数

MyISAM：保存有表的总行数

InnoDB：没有保存表的总行数

9. CURD操作

MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。

InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表

10. 外键

MyISAM：不支持

InnoDB：支持

### 锁

表锁：对整个表加锁，影响标准的所有记录，通常用在数据定义语句中。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

行锁：对一行记录加锁，只影响一条记录，通常用在数据操纵语句中。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

意向锁：属于表锁。为了方便检测表级锁和行级锁之间的冲突，就引入了意向锁。

意向锁分为意向读锁\(IS\)和意向写锁\(IX\)。

意向锁是表级锁，但是却表示事务正在读或写某一行记录，而不是整个表。

在给一行记录加锁前，首先要给该表加意向锁。也就是要同时加表意向锁和行锁。

InnoDB行锁的模式：共享锁（读锁，S锁）、排他锁（写锁、X锁）。

共享锁（读锁）：其他事务可以读，但不能写。

排他锁（写锁）：其他事务不能读取，也不能写。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

乐观锁一般来说有2种实现方式：数据版本（Version）、时间戳（timestamp）。

### 索引

#### 分类

##### 从数据结构角度

1. B+树索引
2. Hash索引
3. FULLTEXT索引
4. R-Tree索引（用于对GIS数据类型创建SPATIAL索引）

补充：

Hash索引与B+树索引的比较

优点：快

缺点：

1. 扩展性差，需要提前预测数据量的大小
2. 不能有序遍历数据
3. B+树磁盘IO次数少
4. Hash索引不能使用范围查询
5. Hash索引无法被用来避免数据的排序操作
6. Hash索引不能利用部分索引键查询

从物理存储角度（B+树索引）

1. 聚簇索引（clustered index）：表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。
2. 非聚簇索引（non-clustered index）：表数据存储顺序与索引顺序无关。

从逻辑角度

1. 主键索引
2. 单列索引
3. 多列索引
4. 唯一索引

失效条件：

1. 查询条件包含OR
2. 组合索引，不是使用第一列索引
3. LIKE以%开头
4. 属性类型是字符串，没有使用引号
5. 当全表扫描速度比索引速度快时，MySQL会使用全表扫描，此时索引失效



