## MySQL

### 范式

#### 第一范式

符合第一范式的关系中的每个属性都不可再分。

不符合第一范式的实例：

![](/assets/database-1nf.jpg)

#### 第二范式

消除了非主属性对于码的部分函数依赖

码：设K为某表中的一个属性或属性组，若除K之外的所有属性都完全函数依赖于K，那么称K为候选码，简称为码。在实际中我们通常可以理解为：假如当K确定的情况下，该表除K之外的所有属性的值也就随之确定，那么K就是码。

### 引擎对比

* 存储结构

MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD \(MYData\)。索引文件的扩展名是.MYI \(MYIndex\)。

InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小。

* 存储空间

MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表、动态表、压缩表。

InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

* 事务支持

MyISAM：强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。

InnoDB：提供事务支持事务，外部键等高级数据库功能。具有事务\(commit\)、回滚\(rollback\)和崩溃修复能力\(crash recovery capabilities\)的事务安全\(transaction-safe \(ACID compliant\)\)型表。

* AUTO\_INCREMENT

MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。

InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。

* 表锁差异

MyISAM：只支持表级锁，用户在操作MyISAM表时，SELECT、UPDATE、DELTE、INSERT语句都会给表自动加锁，如果加锁以后的表满足INSERT并发的情况下，可以在表的尾部插入新的数据。

InnoDB：支持事务和行级锁，是InnoDB的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。

* 全文索引

MyISAM：支持FULLTEXT类型的全文索引

InnoDB：5.6及之前版本不支持FULLTEXT类型的全文索引

* 表主键

MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。

InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键\(用户不可见\)，数据是主索引的一部分，附加索引保存的是主索引的值。

* 表的总行数

MyISAM：保存有表的总行数

InnoDB：没有保存表的总行数

* CURD操作

MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。

InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表

* 外键

MyISAM：不支持

InnoDB：支持

### 锁

* 表锁：对整个表加锁，影响标准的所有记录，通常用在数据定义语句中。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
* 行锁：对一行记录加锁，只影响一条记录，通常用在数据操纵语句中。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
* 意向锁：属于表锁。为了方便检测表级锁和行级锁之间的冲突，就引入了意向锁。

意向锁分为意向读锁\(IS\)和意向写锁\(IX\)。

意向锁是表级锁，但是却表示事务正在读或写某一行记录，而不是整个表。

在给一行记录加锁前，首先要给该表加意向锁。也就是要同时加表意向锁和行锁。

InnoDB行锁的模式：共享锁（读锁，S锁）、排他锁（写锁、X锁）。

* 共享锁（读锁）：其他事务可以读，但不能写。
* 排他锁（写锁）：其他事务不能读取，也不能写。
* 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
* 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

乐观锁一般来说有2种实现方式：数据版本（Version）、时间戳（timestamp）。

### 索引

#### 分类

##### 从数据结构角度

1. B+树索引
2. Hash索引
3. FULLTEXT索引
4. R-Tree索引（用于对GIS数据类型创建SPATIAL索引）

###### Hash索引与B+树索引的比较

优点：快

缺点：

1. 扩展性差，需要提前预测数据量的大小
2. 不能有序遍历数据
3. B+树磁盘IO次数少
4. Hash索引不能使用范围查询
5. Hash索引无法被用来避免数据的排序操作
6. Hash索引不能利用部分索引键查询

##### 从物理存储角度 （B+树索引）

1. 聚簇索引（clustered index）：表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。
2. 非聚簇索引（non-clustered index）：表数据存储顺序与索引顺序无关。

##### 从逻辑角度

1. 主键索引
2. 单列索引
3. 多列索引
4. 唯一索引

#### 失效条件

1. 查询条件包含OR
2. 组合索引，不是使用第一列索引
3. LIKE以%开头
4. 属性类型是字符串，没有使用引号
5. 当全表扫描速度比索引速度快时，MySQL会使用全表扫描，此时索引失效

### 隔离级别

\| **隔离级别** \| **脏读      
** \| **不可重复读      
** \| **幻读** \|  
\| :---: \| :---: \| :---: \| :---: \|  
\| 未提交读 \| 可能 \| 可能 \| 可能 \|  
\| 已提交读 \| 不可能 \| 可能 \| 可能 \|  
\| 可重复读 \| 不可能 \| 不可能 \| 可能 \|  
\| 可串行化 \| 不可能 \| 不可能 \| 不可能 \|

未提交读：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。

提交读：只能读取到已经提交的数据，不可重复读。

可重复读：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。

串行读：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

脏读：指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。

幻读：第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。

### 事务的ACID

特性

数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。

原子性：指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

一致性：指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。

隔离性：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

