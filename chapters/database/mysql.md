## MySQL

### 引擎对比

* 存储结构

MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD \(MYData\)。索引文件的扩展名是.MYI \(MYIndex\)。

InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小。

* 存储空间

MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表、动态表、压缩表。

InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

* 事务支持

MyISAM：强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。

InnoDB：提供事务支持事务，外部键等高级数据库功能。具有事务\(commit\)、回滚\(rollback\)和崩溃修复能力\(crash recovery capabilities\)的事务安全\(transaction-safe \(ACID compliant\)\)型表。

* AUTO\_INCREMENT

MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。

InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。

* 表锁差异

MyISAM：只支持表级锁，用户在操作MyISAM表时，SELECT、UPDATE、DELTE、INSERT语句都会给表自动加锁，如果加锁以后的表满足INSERT并发的情况下，可以在表的尾部插入新的数据。

InnoDB：支持事务和行级锁，是InnoDB的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。

* 全文索引

MyISAM：支持FULLTEXT类型的全文索引

InnoDB：5.6及之前版本不支持FULLTEXT类型的全文索引

* 表主键

MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。

InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键\(用户不可见\)，数据是主索引的一部分，附加索引保存的是主索引的值。

* 表的总行数

MyISAM：保存有表的总行数

InnoDB：没有保存表的总行数

* CURD操作

MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。

InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表

* 外键

MyISAM：不支持

InnoDB：支持

### 锁

#### 分类

##### 按使用方式

* 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁一般来说有2种实现方式：数据版本（Version）、时间戳（timestamp）。
* 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

##### 按粒度

* 表锁：对整个表加锁，影响标准的所有记录，通常用在数据定义语句中。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
    * 意向锁：属于表锁。为了方便检测表级锁和行级锁之间的冲突，就引入了意向锁。意向锁分为意向读锁\(IS\)和意向写锁\(IX\)。
* 行锁：对一行记录加锁，只影响一条记录，通常用在数据操纵语句中。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
    * 共享锁（读锁）：其他事务可以读，但不能写。
    * 排他锁（写锁）：其他事务不能读取，也不能写。
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

#### 引擎支持

* InnoDB行锁和表锁都支持（InnoDB的行锁是基于索引的）
* MyISAM只支持表锁

### 索引

#### 分类

##### 从数据结构角度

1. B+树索引
2. Hash索引
3. FULLTEXT索引
4. R-Tree索引（用于对GIS数据类型创建SPATIAL索引）

###### Hash索引

1. 哈希索引也没办法利用索引完成排序
2. 不支持最左匹配原则
3. 在有大量重复键值情况下，哈希索引的效率很低
4. 不支持范围查询

##### 从物理存储角度 （B+树索引）

1. 聚簇索引（clustered index）：以**主键**创建的索引
2. 非聚簇索引（non-clustered index）：以**非主键**创建的索引

###### 区别

1. 聚集索引在叶子节点存储的是表中的数据
2. 非聚集索引在叶子节点存储的是主键和索引列
3. 使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据

#### 原则

1. 最左前缀匹配原则：MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配。
2. 尽量选择区分度高的列作为索引
3. 索引列不能参与计算，尽量保持列干净
4. 尽可能的扩展索引，不要新建立索引
5. 单个多列组合索引和多个单列索引的检索查询效果不同：因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引。

#### 失效条件

1. 查询条件包含OR
2. 组合索引，不是使用第一列索引
3. LIKE以%开头
4. 属性类型是字符串，没有使用引号
5. 当全表扫描速度比索引速度快时，MySQL会使用全表扫描，此时索引失效

#### 好处
1. 提高数据检索效率，降低数据库的输入输出成本
2. 降低数据排序成本
3. 降低数据分组成本

#### 不足
1. 索引是独立于基础数据的数据库对象，因此它会占用存储空间
2. 数据新增、更新会导致索引的同步更新，所以会增加数据新增、更新所消耗的成本

#### 条件
1. 较为频繁的作为查询条件的字段需要建立索引
2. 唯一性太差的字段不适合单独建立索引，即使频繁作为查询条件
3. 更新非常频繁的字段不适合建立索引
4. 不会出现在查询条件中的字段不需要建立索引

### 游标

游标的设计是一种数据缓冲区的思想，用来存放SQL语句执行的结果。游标是一种能从包括多条数据记录的结果集中每次提取一条记录的机制。

尽管游标能遍历结果中的所有行，但一次只指向一行。

游标的作用就是用于对查询数据库所返回的记录进行遍历，以便进行相应的操作。

#### 特性

1. 不敏感（Asensitive）：数据库可以选择不复制结果集
2. 只读（Read only）
3. 不滚动（Nonscrollable）：游标只能向一个方向前进，并且不可以跳过任何一行数据。

#### 优点

游标是针对行操作的，对从数据库中SELECT查询得到的结果集的每一行可以进行分开的独立的相同或不同的操作，是一种分离的思想。游标是面向集合与面向行的设计思想之间的一种桥梁。

#### 缺点

* 游标的主要缺点是性能不高。
* 游标的开销与游标中进行的操作相关，如果在游标中进行复杂的操作，开销会非常高。
* 游标的缺点是只能一行一行操作。在数据量大的情况下，速度过慢。数据库大部分是面对集合的，业务会比较复杂，而游标使用会有死锁，影响其他的业务操作，不可取。 当数据量大时，使用游标会造成内存不足现象。

#### 适用场景

1. 存储过程
2. 函数
3. 触发器
4. 事件

### 事务

#### 特性

数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。

原子性：指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

一致性：指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。

隔离性：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

#### 隔离级别

| **隔离级别** | **脏读** | **不可重复读** | **幻读** |
| :---: | :---: | :---: | :---: |
| 未提交读 | 可能 | 可能 | 可能 |
| 提交读 | 不可能 | 可能 | 可能 |
| 可重复读 | 不可能 | 不可能 | 可能 |
| 串行读 | 不可能 | 不可能 | 不可能 |

**未提交读**：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。

**提交读**：只能读取到已经提交的数据，不可重复读。

**可重复读**：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。

**串行读**：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

**脏读**：指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

**不可重复读**：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。

**幻读**：第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。

### 日志

1. 错误日志：记录启动、运行或停止时出现的问题
2. 通用日志：记录建立的客户端连接和执行的语句
3. ~~更新日志~~：记录更改数据的语句。（该日志在MySQL 5.1以后已不再使用）
4. 二进制日志：记录所有更改数据的语句，还用于复制。
5. 慢查询日志：记录所有执行时间超过`long_query_time`秒的所有查询或不使用索引的查询。
6. Innodb日志