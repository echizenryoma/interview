## 内存管理基础

### 可执行文件的结构

| ↓stack |
| :--- |
| ↑heap |
| .bss |
| .data |
| .rdata |
| .text |

一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。

只读部分包括程序代码（`.text`）和程序中的常量（`.rdata`）。

可读写部分（也就是变量）大致可以分成下面几个部分：

* `.data`： 初始化了的全局变量和静态变量
* `.bss`： 即 Block Started by Symbol， 未初始化的全局变量和静态变量
* `heap`： 堆，使用 malloc, realloc, 和 free 函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用
* `stack`： 栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中。

**实例代码**

```c
int a = 0; //全局/静态变量区(.data)
char *p1; //未初始化的全局变量和静态变量区(.bss)，编译器默认初始化为NULL

void main()
{
    int b; //栈
    char s[] = "abc"; //栈
    char *p2 = "123456"; //123456在字符串常量区，p2在栈上
    static int c = 0; //c在静态变量区，0为文字常量，在代码区
    const int d = 0; //栈
    static const int d;//静态常量区
    p1 = (char *)malloc(10); //分配得来得10字节在堆区。
    strcpy(p1, "123456"); //123456放在字符串常量区，编译器可能会将它与p2所指向的"123456"优化成一个地方
}
```

### 栈

栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。

栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的。能从栈获得的空间较小。如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示`Stack Overflow`。

栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。

### 堆

堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用`malloc`和`free`时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生memory leak。

堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。

堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

计算机底层并没有对堆的支持，堆则是C/C++函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低。

## 地址空间

* 虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址
* 逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址
* 物理地址：实际物理内存中所看到的存储地址称为物理地址

* 逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间

* 线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间

* 物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间

* MMU\(Memery Management Unit内存管理单元\)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路

* 基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算

* 偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值

虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。

## 虚拟内存

* 请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入

### 页面置换算法

* FIFO算法

  先入先出，即淘汰最早调入的页面。

* OPT\(MIN\)算法

  选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。

  可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。

* LRU\(Least-Recently-Used\)算法

  用过去的历史预测将来，选最近最长时间没有使用的页淘汰\(也称最近最少使用\)。

  LRU准确实现：计数器法，页码栈法。

  由于代价较高，通常不使用准确实现，而是采用近似实现，例如Clock算法。

**内存抖动现象**：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的。

**Belady现象**：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。

FIFO会产生Belady异常。

栈式算法无Belady异常，LRU、LFU（不常用）、OPT都属于栈式算法。

