## 进程管理

### 进程间通信 {#进程间通信}

#### **传统的Unix通信机制**

1. 管道/匿名管道\(pipe\)

2. 具名管道\(FIFO\)

3. 信号\(Signal\)

4. 消息\(Message\)队列

5. 共享内存\(share memory\)

6. 信号量\(semaphore\)

7. 套接字\(socket\)

#### 管道

管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。

该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。

当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。

##### **局限**

* 只支持单向数据流
* 只能用于具有亲缘关系的进程之间
* 没有名字
* 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）
* 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式

#### **Linux系统中常用信号**

* `SIGHUP`：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
* `SIGINT`：程序终止信号。程序运行过程中，按`Ctrl+C`键将产生该信号。
* `SIGQUIT`：程序退出信号。程序运行过程中，按`Ctrl+\`键将产生该信号。
* `SIGBUS`和`SIGSEGV`：程访问非法地址。
* `SIGFPE`：运算中出现致命错误，如除零操作、数据溢出等。
* `SIGKILL`：用户终止进程执行信号。shell下执行`kill -9`发送该信号。
* `SIGTERM`：结束进程信号。shell下执行`kill pid`发送该信号。
* `SIGALRM`：定时器信号。
* `SIGCLD`：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。

### 进程与线程

进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

1. 一个程序至少有一个进程，一个进程至少有一个线程。
2. 线程的划分尺度小于进程，使得多线程程序的并发性高。
3. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4. 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5. 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

### Linux的IO模型

* **同步模型（synchronous IO）**

* 阻塞IO（bloking IO）

* 非阻塞IO（non-blocking IO）

* 多路复用IO（multiplexing IO）

* ~~信号驱动IO（signal-driven IO）~~ 【不常用】

* **异步IO（asynchronous IO）**

|          | **阻塞**                            | **非阻塞**                 |
| :------: | :---------------------------------: | :------------------------: |
| **同步** | read/write                          | read/write\(`O_NONBLOCK`\) |
| **异步** | multiplexing I/O\(`select`/`poll`\) | asynchronous IO            |

#### I/O模型比较

<table>
<tr>
  <td align="center"><b>阻塞IO</b></td>
  <td align="center"><b>非阻塞IO</b></td>
  <td align="center"><b>多路复用IO</b></td>
  <td align="center"><b>信号驱动IO</b></td>
  <td align="center"><b>异步IO</b></td>
</tr>
<tr>
  <td align="center">
    发起<br />
      | <br />
      | <br />
      | <br />
    阻塞<br />
      | <br />
      | <br />
      ↓ <br />
    完成<br />
  </td>
  <td align="center">
    检查<br />
    检查<br />
    …<br />
    检查<br />
    检查<br />
      | <br />
    阻塞<br />
      ↓ <br />
    完成<br />
  </td>
  <td align="center">
    检查<br />
      | <br />
    阻塞<br />
      ↓ <br />
  就绪发起<br />
      | <br />
    阻塞<br />
      ↓ <br />
    完成<br />
  </td>
  <td align="center">
    <br />
    <br />
    <br />
    <br />
    通知发起<br />
      | <br />
     阻塞<br />
      ↓ <br />
    完成<br />
  </td>
  <td align="center">
    发起<br />
    <br />
    <br />
    <br />
    <br />
    <br />
    <br />
    <br />
    通知<br />
  </td>
</tr>
</table>

### IO多路复用（事件驱动）

#### 基本概念

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：

1. 当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。
2. 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。
3. 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。
4. 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。
5. 如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

#### 常见实现方法

* `select`\(Linux/Windows/BSD\)
* `epoll`\(Linux\)
* `kqueue`\(BSD/Mac OS X\)



