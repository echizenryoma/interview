## 进程管理

### 进程与线程

**进程**是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序。

**线程**是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈。

#### 线程

##### 共享

1. 进程代码段
2. 进程的公有数据（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）
3. 进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID

##### 独有

1. 线程ID
2. 寄存器组的值
3. 线程的堆区（stack）
4. 错误返回码
5. 线程的信号屏蔽码
6. 线程的优先级

#### 关系

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。
2. 资源分配给进程，同一进程的所有线程共享该进程的所有资源。
3. 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。
4. 处理机分给线程，即真正在处理机上运行的是线程。
5. 线程是指进程内的一个执行单元，也是进程内的可调度实体。

#### 区别

1. **调度**：在传统操作系统中，拥有资源和独立调度的基本单位都是进程。引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行的线程切换，则会引起进程切换。
2. **拥有资源**：不论是传统的还是引入线程的操作系统，进程都是拥有资源的基本单位，线程不拥有资源（也有一点必不可少的资源），但线程可以共享其隶属进程的系统资源。
3. **并发性**：在引入线程的操作系统中， 不仅进程可以并发执行，而且同一进程内的多个线程也可以并发执行， 从而使操作系统具有更好的并发性，大大提高了系统吞吐量。
4. **系统开销**：创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，因此操作系统所付出的开销远大千创建或撤销线程的开销。类似地，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置；而线程切换时只需保存和设置少量寄存器内容，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现，甚至无须操作系统的干预。
5. **地址空间和其他资源（如打开的文件）**：进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。
6. **通信方面**：进程间通信需要借助操作系统，而线程间可以直接读／写进程数据段（如全局变量）来进行通信。

### 进程间通信

#### Linux进程间通信机制

1. 管道/匿名管道（pipe）

2. 具名管道（FIFO）

3. 信号（signal）

4. 消息队列（message）

5. 共享内存（share memory）

6. 信号量（semaphore）

7. 套接字（socket）

#### 常见实现

* Linux线程间通信：互斥信号量、信号量、条件变量
* Windows进程间通信：管道、共享内存、消息队列、信号量、套接字
* Windows线程间通信：临界区、互斥信号量、信号量、事件

#### Linux常见信号

* `SIGHUP`：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
* `SIGINT`：程序终止信号。程序运行过程中，按`Ctrl+C`键将产生该信号。
* `SIGQUIT`：程序退出信号。程序运行过程中，按`Ctrl+\`键将产生该信号。
* `SIGBUS`和`SIGSEGV`：程访问非法地址。
* `SIGFPE`：运算中出现致命错误，如除零操作、数据溢出等。
* `SIGKILL`：用户终止进程执行信号。shell下执行`kill -9`发送该信号。
* `SIGTERM`：结束进程信号。shell下执行`kill pid`发送该信号。
* `SIGALRM`：定时器信号。
* `SIGCLD`：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。
